---
title: 6.继承与面向对象
weight: 6
---

# Inheritance and Object-Oriented Design

## 32.Make sure public inheritance models "is-a"

public inheritance(公开继承)意味"is-a"（是一种）的关系

## 33.Avoid hideing inherited names

derived classed 内的名称会遮掩base classed内的名称

```c++
class Base{
private:
    int x;
public:
    virtual void mf1() = 0;
    virtual void mf1(int);
    void mf3();
    void mf3(double);
}
class Derived : public Base{
public:
    virtual void mf1();
    void mf3();
    void mf4();
}

Derived d;
int x;
...
d.mf1();
d.mf1(x);//错误
d.mf2();
d.mf3();
d.mf3(x);//错误，因为Derived::mf3遮掩了一个名为Base::mf3但是类型不同的Base函数
```

下面使用using解决上面的问题

```c++
class Base{
private:
    int x;
public:
    virtual void mf1() = 0;
    virtual void mf1(int);
    void mf3();
    void mf3(double);
}
class Derived : public Base{
public:
    using Base::mf1;//让Base class内名为mf1和mf3的所有东西
    using Base::mf3;//在Derived 作用域内都可以(并且public)
    virtual void mf1();
    void mf3();
    void mf4();
}

Derived d;
int x;
...
d.mf1();
d.mf1(x);//正常
d.mf2();
d.mf3();
d.mf3(x);//正常
```

using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见

```c++
class Base{
private:
    int x;
public:
    virtual void mf1() = 0;
    virtual void mf1(int);
}
//Derived唯一想继承的mf1是那个无参数版本，通过转交函数实现
class Derived : privata Base{
public:
    virtual void mf1()//转交函数(forwarding function)
    {
        Base::mf1();
    }
    void mf3();
    void mf4();
}

Derived d;
int x;
...
d.mf1();
d.mf1(x);//正常
```

## 34.Differentiate between inheritance of interface and inheritance of implementation

- 声明pure virtual函数的目的是为了让derived classed 只继承函数接口

- 声明impure virtual函数的目的是为了让derived classed继承该函数的接口和缺省实现

- 声明non-virtual函数的目的是为了让derived classed继承函数的接口及一份强制性实现

  ```c++
  class Airplane{
  public:
      virtual void fly(const Airport& destination) = 0;
      ...
   protected:
      void defaultFly(const Airport& destination);
  };
  
  void Airplane::defaultFly(const Airport& destination)
  {
      //缺省行为
  }
  
  class ModelA: public Airplane{
  public:
      virtual void fly(const Airport& destination)
      {
          defaultFly(destination);
      }
      ...
  };
  
  class ModelB: public Airplane{
  public:
      virtual void fly(const Airport& destination)
      {
          defaultFly(destination);
      }
      ...
  };
  ```

  

## 35.Consider alternatives to virtual functions

- 藉由Non-Virtual Interface手法实现Template Method模式

  ```c++
  class GameCharacter{
  public:
      int healthValue() const
      {
          ...
          int retVal = doHealthValue();
          ...
          return retVal;
      }
  private:
      virtual int doHealthValue() const	//derived classes可重新定义
      {
          ...
      }
  }
  ```

  令客户通过public non-virtual成员函数间接调用private virtual函数,称为non-virtual interface(NVI)手法，把这个non-virtual函数(healthValue)称为virtual函数的外覆器(wrapper)

- 藉由Function Pointers实现Strategy模式

  ```c++
  class GameCharacter;
  int defaultHealthCalc(const GameCharacter& gc);
  class GameCharacter{
  public:
      typedef int (*HealthCalcFunc)(const GameCharacter&);
      explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hcf)
      {
      }
      int healthValue() const
      {
          return healthFunc(*this);
      }
  private:
      HealthCalcFunc healthFunc;
  }
  
  class EvilBadGuy: public GameCharacter{
  public:
      explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc):GameCharacter(hcf)
      {
         ...
      }
      ...
  };
  int loseHealthQuickly(const GameCharacter&);
  int loseHealthSlowly(const GameCharacter&);
  
  EvilBadGuy ebg1(loseHealthQuickly);
  EvilBadGuy ebg2(loseHealthSlowly);
  ```

  古典的strategy模式

  ```c++
  class GameCharacter;
  class HealthCalcFunc{
  public:
      virtual int calc(const GameCharacter& gc) const
      {
          ...
      }
  };
  HealthCalcFunc defaultHealthCalc;
  class GameCharacter{
  public:
      explict GameCharacter(HealthCalcFunc* phcf = &defaultHealthCalc):pHealthCalc(phcf)
      {}
      int healthValue() const 
      {
          return pHealthCalc->calc(*this);
      }
  private:
      HealthCalcFunc* pHealthCalc;
  };
  ```

